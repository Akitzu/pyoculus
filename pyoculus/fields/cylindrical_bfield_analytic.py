from ..toybox.cylindrical_toybox import *
from .cylindrical_bfield import CylindricalBfield
import matplotlib.pyplot as plt
from ..utils.plot import create_canvas
from functools import partial

import logging
logger = logging.getLogger(__name__)

try:
    from jax import jit, jacfwd
    import jax.numpy as jnp
except ImportError as e:
    logger.warning("Could not import jax. Some functionalities will not be available.")
    raise e

class AnalyticCylindricalBfield(CylindricalBfield):
    """Analytical Bfield problem class that allows adding analytical perturbations to an analytical equilibrium field. The equilibrium field is
    derived from the vector potential `A_squared(R, Z, sf, shear)` (circular quadratic q-profile) and the perturbations can be choosen from the
    type dictionary. The possible types are:
        - "maxwell-boltzmann": Maxwell-Boltzmann distributed perturbation
        - "gaussian": Normally distributed perturbation
        - "circular-current-loop": Field generated by a constant current toroidal loop
        - "squared-circle": Field generated by a squared circle (in fact from equ_squared)

    Attributes:
        sf (float): Safety factor on the magnetic axis
        shear (float): Shear factor
        perturbations_args (list): List of dictionaries with the arguments of each perturbation
        amplitude (list): List of amplitudes of the perturbations. One can set the amplitude of all perturbations
            at once by setting this attribute:
            $ myBfield.amplitudes = [1, 2, 3]
            $ myBfield.amplitudes
            >> [1, 2, 3]
        perturbations (list): List of perturbations functions. To call a certain (for instance the first) perturbation one can do:
            $ myBfield.perturbations[0](rphiz)
            >> value

    Methods:
        set_amplitude(index, value): Set the amplitude of the perturbation at index to value
        set_perturbation(index, perturbation_args): Set the perturbation at index to be defined by perturbation_args
        add_perturbation(perturbation_args): Add a new perturbation defined by perturbation_args
        remove_perturbation(index): Remove the perturbation at index, (default: -1, the last one)
        B_equilibrium(rphiz): Equilibrium field function
        dBdX_equilibrium(rphiz): Gradient of the equilibrium field function
        B_perturbation(rphiz): Perturbation field function
        dBdX_perturbation(rphiz): Gradient of the perturbation field function
    """

    _field_types_dict = {
        "squared-circle": rot(A_squared),
        "maxwell-boltzmann": psitob(psi_maxwellboltzmann),
        "gaussian": psitob(psi_gaussian),
        "circular-current-loop": psitob(psi_circularcurrentloop),
    }

    _pot_types_dict = {
        "squared-circle": A_squared,
        "maxwell-boltzmann": A_maxwellboltzmann,
        "gaussian": A_gaussian,
        "circular-current-loop": A_circularcurrentloop,
    }

    def __init__(self, R, Z, sf, shear, perturbations_args=list()):
        """
        Args:
            R (float): Major radius of the magnetic axis of the equilibrium field
            Z (float): Z coordinate of the magnetic axis of the equilibrium field
            sf (float): Safety factor on the magnetic axis
            shear (float): Shear factor
            perturbations_args (list): List of dictionaries with the arguments of each perturbation

        Example:
            $ pert1_dict = {m:2, n:-1, d:1, type: "maxwell-boltzmann", amplitude: 1e-2}
            $ pert2_dict = {m:1, n:0, mu:0, sigma:1, type: "gaussian", amplitude: -1e-2}
            $ myBfield = AnalyticCylindricalBfield(R= 3, sf = 1.1, shear=3 pert=[pert1_dict, pert2_dict])
        """

        self.sf = sf
        self.shear = shear

        # Define the equilibrium vector potential, the field and its gradient
        self.B_equilibrium = partial(
            self._field_types_dict["squared-circle"], R=R, Z=Z, sf=sf, shear=shear
        )
        self.A_equilibrium = partial(
            self._pot_types_dict["squared-circle"], R=R, Z=Z, sf=sf, shear=shear
        )
        self.dBdX_equilibrium = lambda rr: jnp.array(jacfwd(self.B_equilibrium)(rr))

        # Define the perturbations and the gradient of the resulting field sum
        self._perturbations = [None] * len(perturbations_args)
        for pertdic in perturbations_args:
            if "R" not in pertdic.keys():
                pertdic.update({"R": R})
            if "Z" not in pertdic.keys():
                pertdic.update({"Z": Z})

        self.perturbations_args = perturbations_args
        self._initialize_perturbations()

        # Call the CylindricalBfield constructor
        super().__init__(Nfp=1)

    @classmethod
    def with_new_axis(cls, R, Z, sf, shear, perturbations_args=list(), RZguess=None):
        """
        Create a new AnalyticCylindricalBfield object whose axis location
        is found. 
        Perturbations such as circular-current-loop displace the axis. 
        This perturbation is first added, then the axis location is found, 
        and perturbations such as maxwell-boltzmann and gaussian are added
        on this new axis. 
        """
        from ..maps import CylindricalBfieldSection
        # check if there is an axis-shifting perturbation (circular-current-loop)
        if any('circular-current-loop' in pertdic['type'] for pertdic in perturbations_args):
            # create a field with the axis-shifting perturbations
            tmp_field = cls(R, Z, sf, shear, [pertdic for pertdic in perturbations_args if pertdic['type'] == 'circular-current-loop'])
            if RZguess is None:
                RZguess = [R, Z]
            tmp_map = CylindricalBfieldSection.without_axis(tmp_field, guess=RZguess)
            new_R, new_Z = tmp_map.R0, tmp_map.Z0
            # add the axis-located perturbations:
            other_perts = [pertdic for pertdic in perturbations_args if pertdic['type'] != 'circular-current-loop']
            for pert in other_perts:
                if "R" not in pert.keys():
                    pert.update({"R": new_R})
                if "Z" not in pert.keys():
                    pert.update({"Z": new_Z})
                tmp_field.add_perturbation(pert)
            return tmp_field
        else:  # no axis-shifting perturbation
            return cls(R, Z, sf, shear, perturbations_args)

    @property
    def amplitudes(self):
        """List of amplitudes of the perturbations."""
        return [pert["amplitude"] for pert in self.perturbations_args]

    @amplitudes.setter
    def amplitudes(self, value):
        """Set the amplitude of all perturbations at once."""
        for i, pertdic in enumerate(self.perturbations_args):
            pertdic["amplitude"] = value[i]
        self._initialize_perturbations()

    def set_amplitude(self, index, value, find_axis=True):
        """Set the amplitude of the perturbation at index to value"""

        self.perturbations_args[index]["amplitude"] = value
        self._initialize_perturbations(index)

    def set_perturbation(self, index, perturbation_args, find_axis=True):
        """Set the perturbation at index to be defined by perturbation_args"""

        self.perturbations_args[index] = perturbation_args
        # self.perturbations_args[index].update({"R": self.R0, "Z": self.Z0})
        self._initialize_perturbations(index)

    def add_perturbation(self, perturbation_args):
        """Add a new perturbation defined by perturbation_args"""

        self.perturbations_args.append(perturbation_args)
        self._perturbations.append(None)
        # self.perturbations_args[-1].update({"R": self.R0, "Z": self.Z0})
        self._initialize_perturbations(
            len(self.perturbations_args) - 1
        )

    def remove_perturbation(self, index=-1):
        """Remove the perturbation at index or the last one if no index is given."""

        self.perturbations_args.pop(index)
        self._perturbations.pop(index)
        self._initialize_perturbations()

    def _initialize_perturbations(self, index=None):
        """Initialize the perturbations functions and the gradient. Also updates the total field and its gradient."""

        if index is not None:
            indices = [index]
        else:
            indices = range(len(self.perturbations_args))

        for i in indices:
            tmp_args = self.perturbations_args[i].copy()
            tmp_args.pop("amplitude")
            tmp_args.pop("type")

            self._perturbations[i] = partial(
                self._field_types_dict[self.perturbations_args[i]["type"]], **tmp_args
            )

        if len(self.perturbations_args) > 0:
            self.B_perturbation = lambda rr: jnp.sum(
                jnp.array(
                    [
                        pertdic["amplitude"] * self._perturbations[i](rr)
                        for i, pertdic in enumerate(self.perturbations_args)
                    ]
                ),
                axis=0,
            )

            self.A_pertrubation = lambda rr: jnp.sum(
                jnp.array(
                    [
                        pertdic["amplitude"]
                        * self._pot_types_dict[self.perturbations_args[i]["type"]](
                            rr,
                            **{
                                k: v
                                for k, v in pertdic.items()
                                if k not in ["type", "amplitude"]
                            }
                        )
                        for i, pertdic in enumerate(self.perturbations_args)
                    ]
                ),
                axis=0,
            )
        else:
            self.B_perturbation = lambda rr: jnp.array([0, 0, 0])
            self.A_pertrubation = lambda rr: jnp.array([0, 0, 0])

        # gradient of the resulting perturbation
        self.dBdX_perturbation = lambda rr: jnp.array(jacfwd(self.B_perturbation)(rr))

        # Define the total field and its gradient
        self._A = jit(lambda rr: self.A_equilibrium(rr) + self.A_pertrubation(rr))
        self._B = jit(lambda rr: self.B_equilibrium(rr) + self.B_perturbation(rr))
        self._dBdX = jit(
            lambda rr: self.dBdX_equilibrium(rr) + self.dBdX_perturbation(rr)
        )

    @property
    def perturbations(self):
        """List of the perturbations functions (jited using jax). To call a certain (for instance the first) perturbation one can do:
        $ myBfield.perturbations[0](rphiz)
        >> value
        """
        if hasattr(self, "_jited_perturbations") and len(
            self._jited_perturbations
        ) == len(self.perturbations_args):
            return self._jited_perturbations
        else:
            self._jited_perturbations = [
                jit(lambda rr: pertdic["amplitude"] * self._perturbations[i](rr))
                for i, pertdic in enumerate(self.perturbations_args)
            ]
            return self._jited_perturbations

    # BfieldProblem methods implementation

    def B(self, coords, *args):
        """Total field function at the point rr. Where B = B_equilibrium + B_perturbation."""
        return np.array(self._B(coords))

    def dBdX(self, coords, *args):
        """Gradient of the total field function at the point coords. Where (dBdX)^i_j = dB^i/dX^j with i the row index and j the column index of the matrix."""
        rr = np.array(coords)
        return self.B(rr), np.array(self._dBdX(coords))

    def A(self, coords, *args):
        """Total vector potential function at the point rr."""
        return np.array(self._A(coords))

    # def B_many(self, r, phi, z, input1D=True):
    #     return np.array([self._B([r[i], phi[i], z[i]]) for i in range(len(r))])
        
    # def dBdX_many(self, r, phi, z, input1D=True):
    #     return self.B_many(r, phi, z).flatten(), np.array(
    #         [self._dBdX([r[i], phi[i], z[i]]) for i in range(len(r))]
    #     )

    def divB(self, rr):
        """Divergence of the total field function at the point rr."""
        b, dbdx = self.dBdX(rr)
        return dbdx[0, 0] + b[0] / rr[0] + dbdx[1, 1] / rr[0] ** 2 + dbdx[2, 2]

    ## Additional plotting functions

    def plot_perturbation_levels(
        self,
        rw,
        zw,
        nl=[100, 100],
        RZ_manifold=None,
        N_levels=50,
        alpha=0.5,
        colorbar=False,
        **kwargs
    ):
        """Plot the perturbation psi flux function and the perturbation B field in the RZ plane at the provided points.
        The perturbation psi is the sum of the perturbations defined in the perturbations_args attribute.
        """
        fig, ax, kwargs = create_canvas(**kwargs)

        r = np.linspace(rw[0], rw[1], nl[0])
        z = np.linspace(zw[0], zw[1], nl[1])

        psi_mb = jit(psi_maxwellboltzmann)
        psi_g = jit(psi_gaussian)

        R, Z = np.meshgrid(r, z)
        psi = 0
        for pertdic in self.perturbations_args:
            tmp_dict = pertdic.copy()
            tmp_dict.pop("amplitude")
            tmp_dict.pop("type")
            if pertdic["type"] == "maxwell-boltzmann":
                tmp_psi = np.array(
                    [
                        psi_mb([r, 0.0, z], **tmp_dict) / r
                        for r, z in zip(R.flatten(), Z.flatten())
                    ]
                ).reshape(R.shape)
            elif pertdic["type"] == "gaussian":
                tmp_psi = np.array(
                    [
                        psi_g([r, 0.0, z], **tmp_dict) / r
                        for r, z in zip(R.flatten(), Z.flatten())
                    ]
                ).reshape(R.shape)
            else:
                tmp_psi = np.zeros(R.shape)

            psi += pertdic["amplitude"] * np.real(tmp_psi)

        if len(self.perturbations_args) == 0:
            psi = np.zeros(R.shape)
        
        mappable = ax.contourf(R, Z, psi, levels=N_levels, alpha=alpha)
        if colorbar:
            fig.colorbar(mappable)

        if RZ_manifold is not None:
            self.plot_perturbation_vector(RZ_manifold, ax=ax, alpha=alpha)

        return fig, ax

    def plot_perturbation_vector(self, locations, **kwargs):
        """Plot the perturbation vector field at the provided locations."""
        
        fig, ax, kwargs = create_canvas(**kwargs)

        # pop alpha from kwargs or give it 1.0
        alpha = kwargs.pop("alpha", 1.0) 
        
        if locations is not None:
            bfuncts = self.perturbations
            Bs = np.zeros(shape=(locations.shape[0], 3))
            for i, pertdic in enumerate(self.perturbations_args):
                if pertdic["type"] != "circular-current-loop":
                    Bs += np.array([bfuncts[i]([R, 0.0, Z]) for R, Z in locations])

            norms = np.linalg.norm(Bs, axis=1)

            ax.quiver(
                locations[:, 0],
                locations[:, 1],
                Bs[:, 0] / np.linalg.norm(Bs, axis=1),
                Bs[:, 2] / np.linalg.norm(Bs, axis=1),
                alpha=alpha,
                linewidth=0.5,
                **kwargs
            )

        return fig, ax